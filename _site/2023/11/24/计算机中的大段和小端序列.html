<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>大端和小端序列</title>
  <link rel="stylesheet" href="/assets/css/styles.css">
  <link rel="stylesheet" href="/assets/css/fruity.css">
  <style rel="stylesheet">
    html,
    body {
      box-sizing: border-box;
      height: 100%;
      padding: 0;
      margin: 0;
    }

    .page-bar,
    .page-header,
    .page-footer {
      flex-grow: 0;
      flex-shrink: 0;
    }

    hr {
      height: 6px;
      background-color: sandybrown;
      border: none;
    }
  </style>
</head>

<body>
  <div style="display: flex;flex-direction: column;min-height: 100%;">
    <!-- header -->
    <header class="page-header">
    <div class="w3-container w3-center w3-teal">
        <h1>Learning Notes</h1>
        <strong>
            沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。
        </strong>
    </div>
</header>
    <!-- 导航标签 -->
    <!-- 导航标签 -->
<!-- w3-text-black表示当前选中的标签 -->
<div class="w3-bar w3-large w3-teal">
  
  <a href="/"
    class="w3-bar-item w3-button w3-hover-none w3-border-teal w3-hover-text-black w3-bottombar w3-hover-border-white ">Home</a>
  
  <a href="/books.html"
    class="w3-bar-item w3-button w3-hover-none w3-border-teal w3-hover-text-black w3-bottombar w3-hover-border-white ">Books</a>
  
</div>
    <!-- 内容 -->
    <div class="w3-container" style="flex-grow: 1;display: flex;flex-direction: column;">
    <h1>大端和小端序列</h1>

<p>
  24 Nov 2023
  
</p>

<p>电脑存储模式：
大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，存储模式类似把数据当作字符串顺序处理。
小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，存储模式将地址的高低和数据位权有效地结合起来。</p>

<p>名词解析：
大端模式
所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
例子：
0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000
0000440: b484 6c4e 004e ed00 0000 0000 0100 0000
在大端模式下，前32位应该这样读: e6 84 6c 4e ( 假设int占4个字节)
记忆方法: 地址的增长顺序与值的增长顺序相反
小端模式
所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。
例子：
0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000
0000440: b484 6c4e 004e ed00 0000 0000 0100 0000
在小端模式下，前32位应该这样读: 4e 6c 84 e6( 假设int占4个字节)
记忆方法: 地址的增长顺序与值的增长顺序相同
大小端模式
至于为什么要区分大小端，这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令 [1])进行大小端的切换。</p>


</div>
    <!-- footer -->
    <footer class="page-footer">
  <div class="w3-container w3-center w3-teal">
    <h2>just notes~记录点滴</h2>
    <p>copyright@2023 by json</p>
  </div>
</footer>
  </div>
</body>

</html>